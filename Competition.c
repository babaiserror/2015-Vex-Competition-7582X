#pragma config(Sensor, dgtl1,  bump,           sensorTouch)
#pragma config(Sensor, dgtl2,  encoder,        sensorQuadEncoder)
#pragma config(Motor,  port1,           rtLift,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightBack,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rbLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lbLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          ltLift,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(autonomousTest)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define pigs_cant_fly true

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

//functions for driving, t = time in ms
	void gf(int t) //go forwards
	{
		motor[rightFront] = -127;
		motor[rightBack] = -127;
		motor[leftFront] = 127;
		motor[leftBack] = 127;
		wait1Msec(t);
	}
	void gb(int t)//go backwards
	{
		motor[rightFront] = 127;
		motor[rightBack] = 127;
		motor[leftFront] = -127;
		motor[leftBack] = -127;
		wait1Msec(t);
	}
	void gl(int t)//go left
	{
		motor[rightFront] = -127;
		motor[rightBack] = 127;
		motor[leftFront] = 127;
		motor[leftBack] = -127;
		wait1Msec(t);
	}
	void gr(int t)//go right
	{
		motor[rightFront] = 127;
		motor[rightBack] = -127;
		motor[leftFront] = -127;
		motor[leftBack] = 127;
		wait1Msec(t);
	}
	void stopall()//stop all motors
	{
		motor[rightFront] = 0;
		motor[rightBack] = 0;
		motor[leftFront] = 0;
		motor[leftBack] = 0;
		motor[lbLift] = 0;
	  motor[rbLift] = 0;
	  motor[ltLift] = 0;
	  motor[rtLift] = 0;
	  motor[claw] = 0;
		wait1Msec(1);
	}
	void tl(int t)//turn left
	{
		motor[rightFront] = -127;
		motor[rightBack] = -127;
		motor[leftFront] = -127;
		motor[leftBack] = -127;
		wait1Msec(t);
	}
	void tr(int t)//turn right
	{
		motor[rightFront] = 127;
		motor[rightBack] = 127;
		motor[leftFront] = 127;
		motor[leftBack] = 127;
		wait1Msec(t);
	}
	void lu(int t)//lift up
	{
		motor[lbLift] = 127;
	  motor[rbLift] = -127;
	  motor[ltLift] = -127;
	  motor[rtLift] = -127;
	  wait1Msec(t);
	}
	void ld(int t)//lift down
	{
		motor[lbLift] = -127;
	  motor[rbLift] = 127;
	  motor[ltLift] = 127;
	  motor[rtLift] = 127;
	  wait1Msec(t);
	}
	void grab(int t)//grab claw
	{
		motor[claw] = -127;
		wait1Msec(t);
	}
	void open(int t)//open claw
	{
		motor[claw] = 127;
		wait1Msec(t);
	}
//end of motor functions

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	SensorValue[encoder] = 0;
  /////////////////////////////////////////////////////
	////                                             ////
	////             auto 1, blue team               ////
	////                                             ////
	/////////////////////////////////////////////////////
	gr(100);
	while( SensorValue[encoder]< 360 )
		gr(1);
	stopall();
	gf(300);
	stopall();
	lu(1000);
	stopall();
	grab(500);
	lu(500);
	stopall();
	wait1Msec(1000);
	tr(100);
	while( SensorValue[encoder] > -150 )
		tr(1);
	stopall();
	gf(100);
	while(SensorValue[bump] == 0)
		gf(1);
	stopall();
	ld(800);
	open(500);
	gb(500);
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop
  int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;

	while ( pigs_cant_fly )
	{
		//Create "deadzone" for Y1/Ch2
		if(abs(vexRT[Ch2]) > threshold)
			Y1 = -vexRT[Ch2];
		else
			Y1 = 0;

		//Create "deadzone" for X1/Ch1
		if(abs(vexRT[Ch1]) > threshold)
			X1 = -vexRT[Ch1];
		else
			X1 = 0;

		//Create "deadzone" for X2/Ch4
		if(abs(vexRT[Ch4]) > threshold)
			X2 = -vexRT[Ch4];
		else
			X2 = 0;

		//Remote Control Commands
		motor[rightFront] = -X1 - X2 + Y1;
		motor[rightBack] = -X1 + X2 + Y1;
		motor[leftFront] = -X1 + X2 - Y1;
		motor[leftBack] =  -X1 - X2 - Y1;

		//Lift up/down
	  if(vexRT[Btn5U])
	  {
	  	motor[lbLift] = 127;
	  	motor[rbLift] = -127;
	  	motor[ltLift] = -127;
	  	motor[rtLift] = -127;
	  }
	  else if(vexRT[Btn5D])
	  {
	  	motor[lbLift] = -127;
	  	motor[rbLift] = 127;
	  	motor[ltLift] = 127;
	  	motor[rtLift] = 127;
	  }
	  else
	  {
	  	motor[lbLift] = 0;
	  	motor[rbLift] = 0;
	  	motor[ltLift] = 0;
	  	motor[rtLift] = 0;
	  }

	  //claw
	  if(vexRT[Btn6U])
	  	motor[claw] = -127;
	  else if(vexRT[Btn6D])
	  	motor[claw] = 127;
	  else
	  	motor[claw] = 0;
	}
}
